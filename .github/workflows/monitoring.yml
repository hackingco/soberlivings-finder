name: Monitoring and Health Checks

on:
  schedule:
    # Run every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - staging
          - production

jobs:
  health-check-staging:
    name: Monitor Staging Environment
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'all' || github.event.inputs.environment == 'staging'
    
    steps:
      - name: Check API Health
        id: api-health
        run: |
          response=$(curl -s -w "\n%{http_code}" ${{ secrets.STAGING_URL }}/api/health)
          http_code=$(echo "$response" | tail -n 1)
          body=$(echo "$response" | head -n -1)
          
          echo "HTTP Status: $http_code"
          echo "$body" | jq '.'
          
          if [ "$http_code" != "200" ]; then
            echo "::error::Staging API health check failed with status $http_code"
            exit 1
          fi
          
          # Check if database is up
          db_status=$(echo "$body" | jq -r '.checks.database.status')
          if [ "$db_status" != "up" ]; then
            echo "::warning::Staging database is not healthy: $db_status"
          fi

      - name: Check Response Times
        run: |
          # Test key endpoints
          endpoints=(
            "/api/health"
            "/api/v1/facilities?state=CA&limit=1"
            "/api/facilities/search?location=Los%20Angeles"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint..."
            time=$(curl -o /dev/null -s -w "%{time_total}\n" "${{ secrets.STAGING_URL }}$endpoint")
            echo "Response time: ${time}s"
            
            # Alert if response time > 2 seconds
            if (( $(echo "$time > 2" | bc -l) )); then
              echo "::warning::Slow response on $endpoint: ${time}s"
            fi
          done

      - name: Check Database Connectivity
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        run: |
          # Install PostgreSQL client
          sudo apt-get update && sudo apt-get install -y postgresql-client
          
          # Extract connection details
          export PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
          export PGHOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
          export PGUSER=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
          export PGDATABASE=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
          
          # Test connection and get metrics
          psql -c "SELECT COUNT(*) as facility_count FROM facilities;" || echo "::warning::Database query failed"
          psql -c "SELECT pg_database_size(current_database()) as db_size;" || true

      - name: Send Metrics to Monitoring
        if: always()
        run: |
          # Send metrics to your monitoring service
          # Example for Prometheus Pushgateway
          if [ -n "${{ secrets.PROMETHEUS_PUSHGATEWAY_URL }}" ]; then
            cat <<EOF | curl --data-binary @- ${{ secrets.PROMETHEUS_PUSHGATEWAY_URL }}/metrics/job/soberlivings/instance/staging
            # TYPE api_health_status gauge
            api_health_status{environment="staging"} ${{ steps.api-health.outcome == 'success' && '1' || '0' }}
            # TYPE api_response_time_seconds gauge
            api_response_time_seconds{environment="staging",endpoint="/api/health"} ${time:-0}
          EOF
          fi

  health-check-production:
    name: Monitor Production Environment
    runs-on: ubuntu-latest
    if: github.event.inputs.environment == 'all' || github.event.inputs.environment == 'production'
    
    steps:
      - name: Check API Health
        id: api-health
        run: |
          response=$(curl -s -w "\n%{http_code}" ${{ secrets.PRODUCTION_URL }}/api/health)
          http_code=$(echo "$response" | tail -n 1)
          body=$(echo "$response" | head -n -1)
          
          echo "HTTP Status: $http_code"
          echo "$body" | jq '.'
          
          if [ "$http_code" != "200" ]; then
            echo "::error::Production API health check failed with status $http_code"
            exit 1
          fi

      - name: Check Supabase Connection
        run: |
          # Test Supabase endpoint
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "apikey: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" \
            "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}/rest/v1/facilities?limit=1")
          
          if [ "$response" == "200" ]; then
            echo "âœ… Supabase connection healthy"
          else
            echo "::error::Supabase connection failed with status $response"
            exit 1
          fi

      - name: Performance Metrics
        run: |
          # Collect and report performance metrics
          echo "Collecting production performance metrics..."
          
          # Example: Check cache hit rates, connection pool usage, etc.
          metrics=$(curl -s "${{ secrets.PRODUCTION_URL }}/api/metrics" || echo "{}")
          echo "$metrics" | jq '.'

      - name: Alert on Issues
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            // Create an issue if monitoring fails
            const title = `ðŸš¨ Production Monitoring Alert - ${new Date().toISOString()}`;
            const body = `
            ## Production Health Check Failed
            
            **Time**: ${new Date().toISOString()}
            **Job**: ${{ github.job }}
            **Run**: ${{ github.run_id }}
            
            Please investigate immediately.
            
            [View Full Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['production', 'monitoring', 'urgent']
            });

  wordpress-plugin-monitor:
    name: Monitor WordPress Plugin
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
      - name: Check WordPress Health
        run: |
          # Check if WordPress site is up
          response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:8080")
          
          if [ "$response" == "200" ] || [ "$response" == "301" ] || [ "$response" == "302" ]; then
            echo "âœ… WordPress site is accessible"
          else
            echo "::warning::WordPress site returned status $response"
          fi

      - name: Test Plugin Endpoint
        run: |
          # Test the plugin's shortcode page if deployed
          echo "Testing WordPress plugin integration..."
          # Add specific plugin endpoint tests here

  database-metrics:
    name: Collect Database Metrics
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
      - name: Staging Database Metrics
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client
          
          # Extract connection details
          export PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
          export PGHOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
          export PGUSER=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
          export PGDATABASE=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
          
          # Collect metrics
          psql -c "
            SELECT 
              'staging' as environment,
              COUNT(*) as total_facilities,
              COUNT(*) FILTER (WHERE verified = true) as verified_facilities,
              COUNT(DISTINCT state) as states_covered,
              pg_database_size(current_database()) as database_size,
              (SELECT COUNT(*) FROM pg_stat_activity) as active_connections
            FROM facilities;
          " || echo "Failed to collect staging metrics"

      - name: Production Database Metrics
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          # Similar metrics for production
          export PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
          export PGHOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
          export PGUSER=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
          export PGDATABASE=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
          
          psql -c "
            SELECT 
              'production' as environment,
              COUNT(*) as total_facilities,
              COUNT(*) FILTER (WHERE verified = true) as verified_facilities,
              COUNT(DISTINCT state) as states_covered,
              pg_database_size(current_database()) as database_size,
              (SELECT COUNT(*) FROM pg_stat_activity) as active_connections
            FROM facilities;
          " || echo "Failed to collect production metrics"

  generate-report:
    name: Generate Monitoring Report
    runs-on: ubuntu-latest
    needs: [health-check-staging, health-check-production, database-metrics]
    if: always() && github.event_name == 'schedule'
    
    steps:
      - name: Generate Report
        run: |
          cat << EOF > monitoring-report.md
          # SoberLivings Monitoring Report
          
          **Generated**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Run ID**: ${{ github.run_id }}
          
          ## Environment Status
          
          | Environment | API Health | Database | Response Time |
          |-------------|------------|----------|---------------|
          | Staging     | ${{ needs.health-check-staging.result }} | - | - |
          | Production  | ${{ needs.health-check-production.result }} | - | - |
          
          ## Next Steps
          
          1. Review any warnings or errors above
          2. Check Grafana dashboards for detailed metrics
          3. Review application logs for any anomalies
          
          [View Full Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          
          cat monitoring-report.md

      - name: Upload Report
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-report-${{ github.run_id }}
          path: monitoring-report.md